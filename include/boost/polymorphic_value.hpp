// Copyright (c) 2016-2017 Jonathan B. Coe
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP
#define BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP

#include <cassert>
#include <exception>
#include <memory>
#include <type_traits>
#include <typeinfo>

namespace boost {

  template <class T>
  class polymorphic_value;

  template <class T>
  struct default_copy {
    /** _Returns_:  `new T(t)`.
     */
    T* operator()(const T& t) const { return new T(t); }
  };

  ////////////////////////////////////////////////////////////////////////////
  // Implementation detail classes
  ////////////////////////////////////////////////////////////////////////////

  namespace detail {

    template <class T>
    struct control_block {
      
      static_assert(!std::is_const<T>::value,"");
      
      virtual ~control_block() = default;

      virtual std::unique_ptr<control_block> clone() const = 0;

      virtual T* ptr() = 0;
    };

    template <class T, class U = T>
    class direct_control_block : public control_block<T> {
      static_assert(!std::is_reference<U>::value, "");
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      U u_;

    public:
      template <class... Ts>
      explicit direct_control_block(Ts&&... ts)
          : u_(U(std::forward<Ts>(ts)...)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<direct_control_block>(*this);
      }

      T* ptr() override { return &u_; }
    };

    template <class T, class U, class C = default_copy<U>,
              class D = std::default_delete<U>>
    class pointer_control_block : public control_block<T>, public C {
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      std::unique_ptr<U, D> p_;

    public:
      explicit pointer_control_block(U* u, C c = C{}, D d = D{})
          : C(std::move(c)), p_(u, std::move(d)) {}

      explicit pointer_control_block(std::unique_ptr<U, D> p, C c = C{})
          : C(std::move(c)), p_(std::move(p)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        assert(p_);
        return std::make_unique<pointer_control_block>(
            C::operator()(*p_), static_cast<const C&>(*this), p_.get_deleter());
      }

      T* ptr() override { return p_.get(); }
    };

    template <class T, class U>
    class delegating_control_block : public control_block<T> {
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      std::unique_ptr<control_block<U>> delegate_;

    public:
      explicit delegating_control_block(std::unique_ptr<control_block<U>> b)
          : delegate_(std::move(b)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<delegating_control_block>(delegate_->clone());
      }

      T* ptr() override { return delegate_->ptr(); }
    };

    template <class T>
    struct is_polymorphic_value : std::false_type {};

    template <class T>
    struct is_polymorphic_value<polymorphic_value<T>> : std::true_type {};

  } // namespace detail

  class bad_polymorphic_value_construction : std::exception {
  public:
    /** _Effects_: Constructs a `bad_polymorphic_value_construction` object.
     */
    bad_polymorphic_value_construction() noexcept = default;

    /** _Returns_: An implementation-defined NTBS.
     */
    const char* what() const noexcept override {
      return "Dynamic and static type mismatch in polymorphic_value "
             "construction";
    }
  };

  ////////////////////////////////////////////////////////////////////////////////
  // `polymorphic_value` class definition
  ////////////////////////////////////////////////////////////////////////////////

  /** A `polymorphic_value` is an object that owns another object and manages
    that other object through a pointer. More precisely, a `polymorphic_value`
    is an object `v` that stores a pointer to a second object `p` and will
    dispose of `p` when `v` is itself destroyed (e.g., when leaving block
    scope). In this context, `v` is said to own `p`.

    A `polymorphic_value` object is empty if it does not own a pointer.

    Copying a non-empty `polymorphic_value` will copy the owned object so that
    the copied `polymorphic_value` will have its own unique copy of the owned
    object.

    Copying from an empty `polymorphic_value` produces another empty
    `polymorphic_value`.

    Copying and disposal of the owned object can be customized by supplying a
    copier and deleter.

    If a `polymorphic_value` is constructed from a pointer then it is said to
    have a custom copier and deleter. Any `polymorphic_value` instance
    constructed from another `polymorphic_value` instance constructed with a
    custom copier and deleter will also have a custom copier and deleter.

    The template parameter `T` of `polymorphic_value` shall be a non-union class
    type. Otherwise the program is ill-formed.

    The template parameter `T` of `polymorphic_value` may be an incomplete type.
   */
  template <class T>
  class polymorphic_value {
    using element_type = std::remove_const_t<T>;
    
    static_assert(!std::is_union<T>::value, "");
    static_assert(!std::is_function<T>::value, "");
    static_assert(!std::is_array<T>::value, "");
    static_assert(!std::is_pointer<T>::value, "");

    template <class U>
    friend class polymorphic_value;

    template <class U, class V, class... Ts>
    friend polymorphic_value<U> make_polymorphic_value(Ts&&... ts);

    template <class U, class V, class C, class D, class>
    friend polymorphic_value<U> assume_polymorphic_value(V* p, C c, D d);

    template <class T_, class U, class>
    friend polymorphic_value<T_>
    polymorphic_value_cast(const polymorphic_value<U>& p);

    template <class T_, class U, class>
    friend polymorphic_value<T_>
    polymorphic_value_cast(polymorphic_value<U>&& p);

    T* ptr_ = nullptr;
    std::unique_ptr<detail::control_block<element_type>> cb_;

    //
    // Pointer constructor.
    //
    
#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U, class C = default_copy<U>,
              class D = std::default_delete<U>>
#else
    template <class U, class C = default_copy<U>,
              class D = std::default_delete<U>,
              class = std::enable_if_t<std::is_convertible<U*, T*>::value>>
#endif
    /** _Remarks_: This constructor shall not participate in overload resolution
      unless `U*` is convertible to `T*`.  A custom copier and deleter are said
      to be 'present' in a `polymorphic_value` initialized with this
      constructor.

      _Effects_: If `p` is null, creates an empty object, otherwise creates a
      `polymorphic_value` object that owns the pointer `p`.

      If `p` is non-null then the copier and deleter of the `polymorphic_value`
      constructed are initialized from `std::move(c)` and `std::move(d)`.

      _Requires_: `C` and `D` satisfy the requirements of CopyConstructible.
      If `p` is non-null then the expression `c(*p)` returns an object of type
      `U*`. The expression `d(p)` is well formed, has well defined behavior, and
      does not throw exceptions.  Either `U` and `T` must be the same type, or
      the dynamic and static type of `U` must be the same.

      _Throws_: `bad_polymorphic_value_construction` if `is_same_v<C,
      boost::default_copy<U>>`, `is_same_v<D, std::default_delete<U>>` and
      `typeid(*u)!=typeid(U)`; `std::bad_alloc` if required storage cannot be
      obtained.

      _Postconditions_:  `bool(*this) == bool(p)`.
      */
    explicit polymorphic_value(U* u, C copier = C{}, D deleter = D{}) {
      if (!u) {
        return;
      }

      if (std::is_same<D, std::default_delete<U>>::value &&
          std::is_same<C, default_copy<U>>::value && typeid(*u) != typeid(U))
        throw bad_polymorphic_value_construction();

      std::unique_ptr<U, D> p(u, std::move(deleter));

      cb_ = std::make_unique<detail::pointer_control_block<T, U, C, D>>(
          std::move(p), std::move(copier));
      ptr_ = u;
    }

    //
    // Converting constructors.
    //

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<
                  !std::is_same<T, U>::value &&
                  std::is_convertible<std::remove_const_t<U>*, T*>::value>>
#endif
    /**
     * _Remarks_: This constructor shall not participate in overload
     * resolution unless `std::remove_const_t<U>*` is convertible to
     * `std::remove_const_t<T>*`.
     *
     * _Effects_: Creates a `polymorphic_value` object that owns a copy of the
     * object managed by `p`. If `p` has a custom copier then the copy is
     * created by the copier in `p`. Otherwise the copy is created by copy
     * construction of the owned object.  If `p` has a custom copier and deleter
     * then the custom copier and deleter of the `polymorphic_value` constructed
     * are copied from those in `p`.
     *
     * _Throws_: Any exception thrown by the copier or `bad_alloc` if required
     * storage cannot be obtained.
     *
     * _Postconditions_:  `bool(*this) == bool(p)`.
     */
    polymorphic_value(const polymorphic_value<U>& p) {
      cb_ = std::make_unique<
          detail::delegating_control_block<T, std::remove_const_t<U>>>(
          p.cb_->clone());
      ptr_ = cb_->ptr();
    }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<!std::is_same<T, U>::value &&
                                       std::is_convertible<U*, T*>::value>>
#endif
    /** _Remarks_: This constructor shall not participate in overload
      resolution unless `U*` is convertible to `T*`.

     _Effects_: Ownership of the resource managed by `p` is transferred to the
      constructed `polymorphic_value`.  Potentially move constructs the owned
      object (if the dynamic type of the owned object is no-throw
      move-constructible).
      If `p` has a custom copier and deleter then the
     copier and deleter of the `polymorphic_value` constructed are the same as
     those in `p`.

     _Throws_: `std::bad_alloc` if required storage cannot be obtained.

     _Postconditions_:  `*this` contains the old value of `p`. `p` is empty.
    */
    polymorphic_value(polymorphic_value<U>&& p) {
      ptr_ = p.ptr_;
      cb_ = std::make_unique<detail::delegating_control_block<T, U>>(
          std::move(p.cb_));
      p.ptr_ = nullptr;
    }


  public:
    //
    // Destructor
    //

    /** _Effects_: If `!bool(this)` then there are no effects. If a custom
      deleter `d` is present then `d(p)` is called and the copier and deleter
      are destroyed. Otherwise the destructor of the managed object is called.
      */
    ~polymorphic_value() = default;


    //
    // Constructors
    //

    /** _Effects_: Constructs an empty `polymorphic_value`.
     */
    polymorphic_value() {}


    //
    // Copy-constructors
    //

    /** _Effects_: Creates a `polymorphic_value` object that owns a copy of the
    object managed by `p`. If `p` has a custom copier then the copy is created
    by the copier in `p`. Otherwise the copy is created by copy construction of
    the owned object.  If `p` has a custom copier and deleter then the custom
    copier and deleter of the `polymorphic_value` constructed are copied from
    those in `p`.

    _Throws_: Any exception thrown by the copier or `std::bad_alloc` if required
    storage cannot be obtained.

    _Postconditions_:  `bool(*this) == bool(p)`.
    */
    polymorphic_value(const polymorphic_value& p) {
      if (!p) {
        return;
      }
      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
    }

    //
    // Move-constructors
    //
    //

    /** _Effects_: Ownership of the resource managed by `p` is transferred to
     the constructed `polymorphic_value`.  Potentially move constructs the owned
      object (if the dynamic type of the owned object is no-throw
      move-constructible).  If `p` has a custom copier and deleter then the
     copier and deleter of the `polymorphic_value` constructed are the same as
     those in `p`.

     _Throws_: `bad_alloc` if required storage cannot be obtained.

     _Postconditions_:  `*this` contains the old value of `p`. `p` is empty.
    */
    polymorphic_value(polymorphic_value&& p) noexcept {
      ptr_ = p.ptr_;
      cb_ = std::move(p.cb_);
      p.ptr_ = nullptr;
    }

    //
    // Assignment
    //

    /** _Effects_: `*this` owns a copy of the resource managed by `p`.  If `p`
     has a custom copier and deleter then the copy is created by the copier in
     `p`, and the copier and deleter of `*this` are copied from those in `p`.
     Otherwise the resource managed by `*this` is initialised by the copy
     constructor of the resource managed by `p`.

     _Throws_: Any exception thrown by the copier or `bad_alloc` if required
      storage cannot be obtained.

     _Returns_: `*this`.

     _Postconditions_:  `bool(*this) == bool(p)`.
    */
    polymorphic_value& operator=(const polymorphic_value& p) {
      if (&p == this) {
        return *this;
      }

      if (!p) {
        cb_.reset();
        ptr_ = nullptr;
        return *this;
      }

      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
      return *this;
    }

    //
    // Move-assignment
    //

    /** _Effects_: Ownership of the resource managed by `p` is transferred to
     `this`. Potentially move constructs the owned object (if the dynamic type
     of the owned object is no-throw move-constructible).  If `p` has a custom
     copier and deleter then the copier and deleter of `*this` are the same as
     those in `p`.

     _Throws_: `bad_alloc` if required storage cannot be obtained.

     _Returns_: `*this`.

     _Postconditions_: `*this` contains the old value of `p`. `p` is empty.
    */
    polymorphic_value& operator=(polymorphic_value&& p) noexcept {
      if (&p == this) {
        return *this;
      }

      cb_ = std::move(p.cb_);
      ptr_ = p.ptr_;
      p.ptr_ = nullptr;
      return *this;
    }

    //
    // Modifiers
    //

    /** _Effects_: Exchanges the contents of `p` and `*this`.
     */
    void swap(polymorphic_value& p) noexcept {
      using std::swap;
      swap(ptr_, p.ptr_);
      swap(cb_, p.cb_);
    }

    //
    // Observers
    //

    /** _Returns_: `false` if the `polymorphic_value` is empty, otherwise
     * `true`.
     */
    explicit operator bool() const { return (bool)cb_; }

    /** _Requires_: `bool(*this)`.

     _Returns_: A pointer to the owned object.
     */
    const T* operator->() const {
      assert(ptr_);
      return ptr_;
    }

    /** _Requires_: `bool(*this)`.

     _Returns_: A reference to the owned object.
     */
    const T& operator*() const {
      assert(*this);
      return *ptr_;
    }

    /** _Requires_: `bool(*this)`.

     _Returns_: A pointer to the owned object.
     */
    T* operator->() {
      assert(*this);
      return ptr_;
    }

    /** _Requires_: `bool(*this)`.

     _Returns_: A reference to the owned object.
     */
    T& operator*() {
      assert(*this);
      return *ptr_;
    }
  };

  //
  // polymorphic_value creation
  //

  /** _Returns_: A `polymorphic_value<T>` owning an object initialised with
    `U(std::forward<Ts>(ts)...)`.
    */
  template <class T, class U = T, class... Ts>
  polymorphic_value<T> make_polymorphic_value(Ts&&... ts) {
    polymorphic_value<T> p;
    using T_ = std::remove_const_t<T>;
    using U_ = std::remove_const_t<U>;
    p.cb_ = std::make_unique<detail::direct_control_block<T_, U_>>(
        std::forward<Ts>(ts)...);
    p.ptr_ = p.cb_->ptr();
    return std::move(p);
  }

  //
  // polymorphic_value creation from pointer with custom copy and delete
  //
  /** _Returns_: TODO
   */
#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
  template <class T, class U, class C = default_copy<U>,
            class D = std::default_delete<U>>
#else
  template <class T, class U, class C = default_copy<U>,
            class D = std::default_delete<U>,
            class = std::enable_if_t<std::is_convertible<U*, T*>::value>>
#endif
  polymorphic_value<T> assume_polymorphic_value(U* u, C copier = {},
                                                D deleter = {}) {
    return polymorphic_value<T>(u, std::move(copier), std::move(deleter));
  }

  template <class T, class U,
            class = std::enable_if_t<
                !std::is_same<T, U>::value &&
                std::is_convertible<std::remove_const_t<U>*, T*>::value>>
  polymorphic_value<T> polymorphic_value_cast(const polymorphic_value<U>& p) {
    return polymorphic_value<T>(p);
  }
  
  template <class T, class U,
            class = std::enable_if_t<
                !std::is_same<T, U>::value &&
                std::is_convertible<std::remove_const_t<U>*, T*>::value>>
  polymorphic_value<T> polymorphic_value_cast(polymorphic_value<U>&& p) {
    return polymorphic_value<T>(std::move(p));
  }
  
  //
  // non-member swap
  //

  /** _Effects_: Equivalent to `p.swap(u)`.
   */
  template <class T>
  void swap(polymorphic_value<T>& t, polymorphic_value<T>& u) noexcept {
    t.swap(u);
  }

} // namespace boost

#endif // BOOST_POLYMORPHIC_VALUE_12JUL2018_HPP
