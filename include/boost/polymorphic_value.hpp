// Copyright (c) 2016-2017 Jonathan B. Coe
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef BOOST_POLYMORPHIC_VALUE_12JUN2018_HPP
#define BOOST_POLYMORPHIC_VALUE_12JUN2018_HPP

#include <cassert>
#include <exception>
#include <memory>
#include <type_traits>
#include <typeinfo>

namespace boost {

  template <class T>
  class polymorphic_value;

  template <class T>
  struct default_copy {
    T* operator()(const T& t) const { return new T(t); }
  };

  template <class T>
  struct default_delete {
    void operator()(const T* t) const { delete t; }
  };

  ////////////////////////////////////////////////////////////////////////////
  // Implementation detail classes
  ////////////////////////////////////////////////////////////////////////////

  namespace detail {

    template <class T>
    struct control_block {
      
      static_assert(!std::is_const<T>::value,"");
      
      virtual ~control_block() = default;

      virtual std::unique_ptr<control_block> clone() const = 0;

      virtual T* ptr() = 0;
    };

    template <class T, class U = T>
    class direct_control_block : public control_block<T> {
      static_assert(!std::is_reference<U>::value, "");
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      U u_;

    public:
      template <class... Ts>
      explicit direct_control_block(Ts&&... ts)
          : u_(U(std::forward<Ts>(ts)...)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<direct_control_block>(*this);
      }

      T* ptr() override { return &u_; }
    };

    template <class T, class U, class C = default_copy<U>,
              class D = default_delete<U>>
    class pointer_control_block : public control_block<T>, public C {
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      std::unique_ptr<U, D> p_;

    public:
      explicit pointer_control_block(U* u, C c = C{}, D d = D{})
          : C(std::move(c)), p_(u, std::move(d)) {}

      explicit pointer_control_block(std::unique_ptr<U, D> p, C c = C{})
          : C(std::move(c)), p_(std::move(p)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        assert(p_);
        return std::make_unique<pointer_control_block>(
            C::operator()(*p_), static_cast<const C&>(*this), p_.get_deleter());
      }

      T* ptr() override { return p_.get(); }
    };

    template <class T, class U>
    class delegating_control_block : public control_block<T> {
      static_assert(!std::is_const<T>::value,"");
      static_assert(!std::is_const<U>::value,"");
      
      std::unique_ptr<control_block<U>> delegate_;

    public:
      explicit delegating_control_block(std::unique_ptr<control_block<U>> b)
          : delegate_(std::move(b)) {}

      std::unique_ptr<control_block<T>> clone() const override {
        return std::make_unique<delegating_control_block>(delegate_->clone());
      }

      T* ptr() override { return delegate_->ptr(); }
    };

    template <class T>
    struct is_polymorphic_value : std::false_type {};

    template <class T>
    struct is_polymorphic_value<polymorphic_value<T>> : std::true_type {};

  } // namespace detail

  class bad_polymorphic_value_construction : std::exception {
  public:
    bad_polymorphic_value_construction() noexcept = default;

    const char* what() const noexcept override {
      return "Dynamic and static type mismatch in polymorphic_value "
             "construction";
    }
  };

  ////////////////////////////////////////////////////////////////////////////////
  // `polymorphic_value` class definition
  ////////////////////////////////////////////////////////////////////////////////

  template <class cT> // Take a const-qualified T. Control block owns a non-const T. 
  class polymorphic_value {
    using T = std::remove_const_t<cT>;
    
    static_assert(!std::is_union<T>::value, "");
    static_assert(!std::is_function<T>::value, "");
    static_assert(!std::is_array<T>::value, "");
    static_assert(!std::is_pointer<T>::value, "");

    template <class U>
    friend class polymorphic_value;

    template <class T_, class... Ts>
    friend polymorphic_value<T_> make_polymorphic_value(Ts&&... ts);

    T* ptr_ = nullptr;
    std::unique_ptr<detail::control_block<T>> cb_;

  public:
    //
    // Destructor
    //

    ~polymorphic_value() = default;


    //
    // Constructors
    //

    polymorphic_value() {}

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U, class C = default_copy<U>, class D = default_delete<U>>
#else
    template <class U, class C = default_copy<U>, class D = default_delete<U>,
              class = std::enable_if_t<std::is_convertible<U*, T*>::value>>
#endif
    /** requires `U*` is convertible to `T*`.
     * If `C` is `default_copy<U>` and `D` is `default_delete<U>`, requires
     * `typeid(*u) == typeid(U)`. */
    explicit polymorphic_value(U* u, C copier = C{}, D deleter = D{}) {
      if (!u) {
        return;
      }

      if (std::is_same<D, default_delete<U>>::value &&
          std::is_same<C, default_copy<U>>::value && typeid(*u) != typeid(U))
        throw bad_polymorphic_value_construction();

      std::unique_ptr<U, D> p(u, std::move(deleter));

      cb_ = std::make_unique<detail::pointer_control_block<T, U, C, D>>(
          std::move(p), std::move(copier));
      ptr_ = u;
    }


    //
    // Copy-constructors
    //

    polymorphic_value(const polymorphic_value& p) {
      if (!p) {
        return;
      }
      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
    }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<
                  !std::is_same<T, U>::value &&
                  std::is_convertible<std::remove_const_t<U>*, T*>::value>>
#endif
    /** requires `T` and `U` are different types, `std::remove_const_t<U>*` is
       convertible to `T*`. */
    polymorphic_value(const polymorphic_value<U>& p) {
      polymorphic_value<U> tmp(p);
      ptr_ = tmp.ptr_;
      cb_ = std::make_unique<
          detail::delegating_control_block<T, std::remove_const_t<U>>>(
          std::move(tmp.cb_));
    }

    //
    // Move-constructors
    //

    polymorphic_value(polymorphic_value&& p) noexcept {
      ptr_ = p.ptr_;
      cb_ = std::move(p.cb_);
      p.ptr_ = nullptr;
    }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<!std::is_same<T, U>::value &&
                                       std::is_convertible<U*, T*>::value>>
#endif
    /** requires `T` and `U` are different types, `U*` is convertible to `T*`.
     */
    polymorphic_value(polymorphic_value<U>&& p) {
      ptr_ = p.ptr_;
      cb_ = std::make_unique<detail::delegating_control_block<T, U>>(
          std::move(p.cb_));
      p.ptr_ = nullptr;
    }

    //
    // Forwarding constructor
    //

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<
                  std::is_convertible<std::decay_t<U>*, T*>::value &&
                  !detail::is_polymorphic_value<std::decay_t<U>>::value>>
#endif
    /** requires `std::decay_t<U>` is not a `polymorphic_value`,
     * `std::decay_t<U>*` is convertible to `T*`. */
    polymorphic_value(U&& u)
        : cb_(std::make_unique<
              detail::direct_control_block<T, std::decay_t<U>>>(
              std::forward<U>(u))) {
      ptr_ = cb_->ptr();
    }

    //
    // Assignment
    //

    polymorphic_value& operator=(const polymorphic_value& p) {
      if (&p == this) {
        return *this;
      }

      if (!p) {
        cb_.reset();
        ptr_ = nullptr;
        return *this;
      }

      auto tmp_cb = p.cb_->clone();
      ptr_ = tmp_cb->ptr();
      cb_ = std::move(tmp_cb);
      return *this;
    }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<
                  !std::is_same<T, U>::value &&
                  std::is_convertible<std::remove_const_t<U>*, T*>::value>>
#endif
    /** requires `T` and `U` are different types, `U*` is convertible to `T*`.
     */
    polymorphic_value& operator=(const polymorphic_value<U>& p) {
      if (!p)
      {
        return *this;
      }
      polymorphic_value<U> tmp(p);
      cb_ = std::make_unique<
          detail::delegating_control_block<T, std::remove_const_t<U>>>(
          std::move(tmp.cb_));
      ptr_ = cb_ ? cb_->ptr() : nullptr;
      return *this;
    }

    //
    // Move-assignment
    //

    polymorphic_value& operator=(polymorphic_value&& p) noexcept {
      if (&p == this) {
        return *this;
      }

      cb_ = std::move(p.cb_);
      ptr_ = p.ptr_;
      p.ptr_ = nullptr;
      return *this;
    }

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<!std::is_same<T, U>::value &&
                                       std::is_convertible<U*, T*>::value>>
#endif
    /** requires `T` and `U` are different types, `U*` is convertible to `T*`.
     */
    polymorphic_value& operator=(polymorphic_value<U>&& p) {
      cb_ = std::make_unique<detail::delegating_control_block<T, U>>(
          std::move(p.cb_));
      ptr_ = p.ptr_;
      p.ptr_ = nullptr;
      return *this;
    }

    //
    // Forwarding assignment
    //

#ifdef BOOST_POLYMORPHIC_VALUE_DOXYGEN
    template <class U>
#else
    template <class U,
              class = std::enable_if_t<
                  std::is_convertible<std::decay_t<U>*, T*>::value &&
                  !detail::is_polymorphic_value<std::decay_t<U>>::value>>
#endif
    /** requires `std::decay_t<U>` is not a `polymorphic_value`,
     * `std::decay_t<U>*` is convertible to `T*`. */
    polymorphic_value& operator=(U&& u) {
      polymorphic_value tmp(std::forward<U>(u));
      *this = std::move(tmp);
      return *this;
    }

    //
    // Modifiers
    //

    void swap(polymorphic_value& p) noexcept {
      using std::swap;
      swap(ptr_, p.ptr_);
      swap(cb_, p.cb_);
    }

    //
    // Observers
    //

    /** returns true if there is a managed object, otherwise returns false. */
    explicit operator bool() const { return (bool)cb_; }

    /** requires a managed object. */
    const T* operator->() const {
      assert(ptr_);
      return ptr_;
    }

    /** requires a managed object. */
    const T& value() const {
      assert(*this);
      return *ptr_;
    }

    /** requires a managed object. */
    const T& operator*() const {
      assert(*this);
      return *ptr_;
    }

    /** requires a managed object. */
    T* operator->() {
      assert(*this);
      return ptr_;
    }

    /** requires a managed object. */
    T& value() {
      assert(*this);
      return *ptr_;
    }

    /** requires a managed object. */
    T& operator*() {
      assert(*this);
      return *ptr_;
    }
  };

  //
  // polymorphic_value creation
  //

  template <class T, class... Ts>
  polymorphic_value<T> make_polymorphic_value(Ts&&... ts) {
    polymorphic_value<T> p;
    p.cb_ = std::make_unique<detail::direct_control_block<T>>(
        std::forward<Ts>(ts)...);
    p.ptr_ = p.cb_->ptr();
    return std::move(p);
  }

  //
  // non-member swap
  //

  template <class T>
  void swap(polymorphic_value<T>& t, polymorphic_value<T>& u) noexcept {
    t.swap(u);
  }

} // namespace boost

#endif // BOOST_POLYMORPHIC_VALUE_12JUN2018_HPP
